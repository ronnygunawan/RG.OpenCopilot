# Executor Service Documentation

## Overview

The `ExecutorService` is responsible for executing the plan generated by the planner. It clones the repository, applies changes, runs tests, commits, and pushes to the working branch, and posts progress updates to the pull request.

## Components

### 1. ExecutorService

The main service that orchestrates the execution of a plan.

**Key Responsibilities:**
- Clone the repository using GitHub App installation tokens
- Execute plan steps in order
- Commit and push changes to the working branch
- Post progress comments to the pull request
- Clean up cloned repositories

**Usage:**
```csharp
var executor = serviceProvider.GetRequiredService<IExecutorService>();
await executor.ExecutePlanAsync(agentTask, cancellationToken);
```

### 2. GitHubAppTokenProvider

Provides GitHub App installation tokens for authentication.

**Configuration:**
```json
{
  "GitHub": {
    "AppId": "123456",
    "AppPrivateKey": "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
  }
}
```

**Features:**
- Generates JWT tokens signed with RS256 for GitHub App authentication
- Creates installation access tokens with appropriate permissions
- Falls back gracefully when GitHub App credentials are not configured (for POC/testing)

### 3. GitCommandRepositoryCloner

Clones repositories using Git command-line interface.

**Features:**
- Clones specific branch using `--single-branch` for efficiency
- Uses installation tokens for authentication
- Creates temporary directories for clones
- Handles cleanup of cloned repositories

**Implementation Details:**
- Repositories are cloned to: `/tmp/opencopilot-repos/{owner}-{repo}-{guid}`
- Authentication uses `x-access-token` format in Git URLs
- Single-branch clone reduces clone time and disk usage

### 4. ProcessCommandExecutor

Executes commands in a subprocess with proper output/error capture.

**Features:**
- Executes arbitrary commands in specified working directory
- Captures stdout and stderr separately
- Returns structured `CommandResult` with exit code, output, and errors
- Supports cancellation tokens

**Common Commands:**
```csharp
// Check for uncommitted changes
var result = await executor.ExecuteCommandAsync(
    repoPath, 
    "git", 
    new[] { "status", "--porcelain" },
    cancellationToken);

// Run tests
var result = await executor.ExecuteCommandAsync(
    repoPath, 
    "dotnet", 
    new[] { "test" },
    cancellationToken);

// Build the project
var result = await executor.ExecuteCommandAsync(
    repoPath, 
    "npm", 
    new[] { "run", "build" },
    cancellationToken);
```

### 5. GitHubService Extensions

New methods added to `IGitHubService`:

**GetPullRequestNumberForBranchAsync**
- Finds the PR number for a given branch
- Returns `null` if no open PR is found

**PostPullRequestCommentAsync**
- Posts a comment to a pull request
- Used for progress updates

## Workflow

1. **Initialize**: Executor service receives an `AgentTask` with a `Plan`
2. **Clone**: Repository is cloned to a temporary directory using installation token
3. **Execute Steps**: Each plan step is executed in order
4. **Commit & Push**: Changes are committed and pushed to the working branch
5. **Comment**: Progress update is posted to the PR
6. **Cleanup**: Cloned repository is removed from temporary storage

## Configuration

### GitHub App Credentials

For production use with a GitHub App:

```json
{
  "GitHub": {
    "AppId": "123456",
    "AppPrivateKey": "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA...\n-----END RSA PRIVATE KEY-----"
  }
}
```

### Personal Access Token (for POC/Testing)

For development without a GitHub App:

```json
{
  "GitHub": {
    "Token": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  }
}
```

**Note:** The token provider will return an empty string if App credentials are not configured, allowing the executor to fall back to the configured personal access token for Git operations.

## Security Considerations

1. **Installation Tokens**: Automatically expire after 1 hour
2. **Temporary Storage**: Repositories are cloned to temporary directories and cleaned up
3. **Command Execution**: Commands run in isolated processes
4. **Token Handling**: Tokens are never logged or exposed in error messages

## Testing

The executor service includes comprehensive tests:

- `ExecutorServiceTests.ExecutePlanAsync_ThrowsWhenPlanIsNull`
- `ExecutorServiceTests.ExecutePlanAsync_UpdatesTaskStatusToExecuting`
- `ExecutorServiceTests.ExecutePlanAsync_ClonesRepository`
- `ExecutorServiceTests.ExecutePlanAsync_MarksStepsAsDone`
- `ExecutorServiceTests.ExecutePlanAsync_PostsProgressComment`
- `ExecutorServiceTests.ExecutePlanAsync_CleansUpRepositoryOnSuccess`
- `ExecutorServiceTests.ProcessCommandExecutor_ExecutesCommand`
- `ExecutorServiceTests.ProcessCommandExecutor_ReturnsFailureForNonExistentCommand`

Run tests with:
```bash
dotnet test
```

## Limitations & Future Enhancements

### Current Limitations

1. **No LLM Integration**: Steps are marked as done without actual code changes
2. **Basic Error Handling**: Failed steps don't provide detailed diagnostics
3. **No Retry Logic**: Commands are not retried on transient failures
4. **Synchronous Execution**: Long-running tasks block the thread

### Planned Enhancements

1. **LLM-Driven Execution**: Integrate with cheaper models to determine actual code changes
2. **Background Processing**: Use background jobs for long-running executions
3. **Persistent Storage**: Store execution state in a database
4. **Advanced Error Recovery**: Retry failed commands and steps
5. **Sandbox Improvements**: Run commands in Docker containers for better isolation
6. **Incremental Commits**: Commit after each step instead of at the end
7. **Test Execution**: Actually run tests and capture results
8. **Build Verification**: Ensure code compiles before committing

## Example Usage

```csharp
// In WebhookHandler or a background job
var task = new AgentTask
{
    Id = "owner/repo/issues/123",
    InstallationId = 12345,
    RepositoryOwner = "owner",
    RepositoryName = "repo",
    IssueNumber = 123,
    Plan = new AgentPlan
    {
        ProblemSummary = "Fix bug in authentication",
        Steps = new List<PlanStep>
        {
            new() { Id = "1", Title = "Update auth middleware", Details = "Add missing null check" },
            new() { Id = "2", Title = "Add unit tests", Details = "Cover the new code path" }
        }
    }
};

// Execute the plan
await executorService.ExecutePlanAsync(task, cancellationToken);

// Task status is now Completed
// Changes are committed and pushed
// PR has a progress comment
```

## Troubleshooting

### Repository Clone Failures

- Ensure the installation token has `contents: write` permission
- Check that the branch exists in the repository
- Verify network connectivity to GitHub

### Command Execution Failures

- Ensure required tools (git, dotnet, npm, etc.) are installed
- Check working directory permissions
- Review command output in logs

### PR Comment Failures

- Verify installation token has `pull_requests: write` permission
- Ensure the PR exists and is open
- Check for rate limiting issues

## See Also

- [PLAN.md](PLAN.md) - Overall architecture and implementation plan
- [POC-SETUP.md](POC-SETUP.md) - Setup instructions
- [LLM-CONFIGURATION.md](LLM-CONFIGURATION.md) - LLM configuration guide
