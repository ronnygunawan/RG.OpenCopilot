# Executor Service Documentation

## Overview

The executor service is responsible for executing the plan generated by the planner. It runs in isolated Docker containers, applies code changes, runs builds and tests, commits changes, and posts progress updates to pull requests.

## Architecture

The executor service now uses a **container-based architecture** for enhanced isolation and security:

1. **Short-lived containers**: Each task execution runs in a fresh Docker container
2. **Isolated environment**: Build, test, and code modifications happen in isolation
3. **Automatic cleanup**: Containers are removed after execution completes
4. **MCP tool integration**: Uses Model Context Protocol tools for file operations

## Components

### 1. ContainerExecutorService

The main service that orchestrates container-based execution of plans.

**Key Responsibilities:**
- Create isolated Docker containers for each task
- Clone repositories inside containers using GitHub App installation tokens
- Execute plan steps with build/test verification
- Commit and push changes from containers
- Post progress comments to pull requests
- Clean up containers after execution

**Usage:**
```csharp
var executor = serviceProvider.GetRequiredService<IExecutorService>();
await executor.ExecutePlanAsync(agentTask, cancellationToken);
```

### 2. DockerContainerManager

Manages the lifecycle of Docker containers used for task execution.

**Features:**
- Creates containers from `mcr.microsoft.com/dotnet/sdk:10.0` base image
- Clones repositories inside containers with Git authentication
- Executes commands in containers with proper output capture
- Supports file read/write operations inside containers
- **Directory operations** with workspace safety validation (see below)
- Commits and pushes changes from containers
- Automatic container cleanup

**Key Methods:**
```csharp
// Create a container and clone the repository
string containerId = await containerManager.CreateContainerAsync(owner, repo, token, branch);

// Execute commands in the container
CommandResult result = await containerManager.ExecuteInContainerAsync(containerId, "dotnet", new[] { "build" });

// Read/write files
string content = await containerManager.ReadFileInContainerAsync(containerId, "Program.cs");
await containerManager.WriteFileInContainerAsync(containerId, "NewFile.cs", content);

// Directory operations (all paths validated to be within /workspace)
await containerManager.CreateDirectoryAsync(containerId, "src/components");
bool exists = await containerManager.DirectoryExistsAsync(containerId, "src");
await containerManager.MoveAsync(containerId, "old-dir", "new-dir");
await containerManager.CopyAsync(containerId, "template", "feature");
await containerManager.DeleteAsync(containerId, "temp-dir", recursive: true);
List<string> files = await containerManager.ListContentsAsync(containerId, "src");

// Commit and push changes
await containerManager.CommitAndPushAsync(containerId, "Implement feature", owner, repo, branch, token);

// Cleanup
await containerManager.CleanupContainerAsync(containerId);
```

#### Directory Operations

The `DockerContainerManager` implements the `IDirectoryOperations` interface, providing comprehensive directory management capabilities for container file systems.

**Available Operations:**

1. **CreateDirectoryAsync** - Creates directories with parent support (`mkdir -p`)
   ```csharp
   // Creates nested directories in one call
   await manager.CreateDirectoryAsync(containerId, "src/components/ui");
   ```

2. **DirectoryExistsAsync** - Checks if a directory exists
   ```csharp
   bool exists = await manager.DirectoryExistsAsync(containerId, "src/components");
   ```

3. **MoveAsync** - Moves or renames files and directories
   ```csharp
   // Rename a directory
   await manager.MoveAsync(containerId, "old-name", "new-name");
   
   // Move a file to a different directory
   await manager.MoveAsync(containerId, "file.txt", "archive/file.txt");
   ```

4. **CopyAsync** - Copies files and directories recursively
   ```csharp
   // Copy a directory with all its contents
   await manager.CopyAsync(containerId, "template-dir", "new-feature-dir");
   
   // Copy a single file
   await manager.CopyAsync(containerId, "config.json", "config.backup.json");
   ```

5. **DeleteAsync** - Deletes files or directories
   ```csharp
   // Delete a file
   await manager.DeleteAsync(containerId, "temp-file.txt");
   
   // Delete a directory recursively
   await manager.DeleteAsync(containerId, "build-output", recursive: true);
   ```

6. **ListContentsAsync** - Lists directory contents
   ```csharp
   List<string> files = await manager.ListContentsAsync(containerId, "src");
   // Returns: ["Program.cs", "Utils.cs", "Models"]
   ```

**Security Features:**

All directory operations include robust path validation to prevent directory traversal attacks:

- Paths are normalized using `Path.GetFullPath`
- All operations are restricted to the `/workspace` directory
- Attempts to access paths outside `/workspace` throw `InvalidOperationException`
- Null or empty paths are rejected with clear error messages

**Example Usage:**

```csharp
// Organize code into a new feature structure
await manager.CreateDirectoryAsync(containerId, "src/Features/Authentication");
await manager.CopyAsync(containerId, "src/Templates/Feature", "src/Features/Authentication");
await manager.MoveAsync(containerId, "src/OldAuth.cs", "src/Features/Authentication/AuthService.cs");

// Clean up temporary files
await manager.DeleteAsync(containerId, "obj", recursive: true);
await manager.DeleteAsync(containerId, "bin", recursive: true);

// Verify structure
var files = await manager.ListContentsAsync(containerId, "src/Features/Authentication");
```

### 3. GitHubAppTokenProvider

Provides GitHub App installation tokens for authentication.

**Configuration:**
```json
{
  "GitHub": {
    "AppId": "123456",
    "AppPrivateKey": "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
  }
}
```

**Features:**
- Generates JWT tokens signed with RS256 for GitHub App authentication
- Creates installation access tokens with appropriate permissions
- Falls back gracefully when GitHub App credentials are not configured (for POC/testing)

### 4. ProcessCommandExecutor

Executes commands in subprocesses with proper output/error capture. Used by ContainerManager to interact with Docker.

**Features:**
- Executes arbitrary commands (including `docker` commands)
- Captures stdout and stderr separately
- Returns structured `CommandResult` with exit code, output, and errors
- Supports cancellation tokens

**Common Commands (executed via Docker):**
```csharp
// Create and run a container
var result = await executor.ExecuteCommandAsync(
    workDir,
    "docker",
    new[] { "run", "-d", "--name", "container-name", "image", "command" },
    cancellationToken);

// Execute command in container
var result = await executor.ExecuteCommandAsync(
    workDir,
    "docker",
    new[] { "exec", "container-id", "dotnet", "build" },
    cancellationToken);

// Stop and remove container
await executor.ExecuteCommandAsync(workDir, "docker", new[] { "stop", "container-id" }, cancellationToken);
await executor.ExecuteCommandAsync(workDir, "docker", new[] { "rm", "container-id" }, cancellationToken);
```

### 5. GitHubService Extensions

New methods added to `IGitHubService`:

**GetPullRequestNumberForBranchAsync**
- Finds the PR number for a given branch
- Returns `null` if no open PR is found

**PostPullRequestCommentAsync**
- Posts a comment to a pull request
- Used for progress updates

## Workflow

1. **Initialize**: Executor service receives an `AgentTask` with a `Plan`
2. **Create Container**: A fresh Docker container is created with the base image
3. **Clone Repository**: Repository is cloned inside the container using installation token
4. **Execute Steps**: Each plan step is executed in the isolated container environment
   - Detect project type (.NET, Node.js, Python, etc.)
   - Run build commands
   - Run tests to verify changes
   - Use MCP tools for file operations (future enhancement)
5. **Commit & Push**: Changes are committed and pushed from the container
6. **Comment**: Progress update is posted to the PR
7. **Cleanup**: Container is stopped and removed

## Container Environment

### Base Image

The executor uses `mcr.microsoft.com/dotnet/sdk:10.0` as the base image, which includes:
- .NET 10.0 SDK
- Ubuntu-based Linux environment
- Git (installed during container setup)

### Working Directory

All operations happen in `/workspace` inside the container.

### Automatic Project Detection

The executor automatically detects project types and runs appropriate commands:

- **.NET Projects**: Runs `dotnet build` and `dotnet test`
- **Node.js Projects**: Runs `npm install` and `npm test`
- **Python Projects**: Runs `pip install -r requirements.txt`

## Configuration

### Docker Requirements

The host system must have Docker installed and the Docker daemon running. The executor uses the `docker` CLI to manage containers.

### GitHub App Credentials

For production use with a GitHub App:

```json
{
  "GitHub": {
    "AppId": "123456",
    "AppPrivateKey": "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA...\n-----END RSA PRIVATE KEY-----"
  }
}
```

### Personal Access Token (for POC/Testing)

For development without a GitHub App:

```json
{
  "GitHub": {
    "Token": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  }
}
```

**Note:** The token provider will return an empty string if App credentials are not configured, allowing the executor to use alternative authentication methods.

## Security Considerations

1. **Container Isolation**: Each task runs in a fresh, isolated Docker container
2. **Short-lived Containers**: Containers are automatically removed after execution
3. **Installation Tokens**: Automatically expire after 1 hour
4. **No Host Access**: Containers run with limited privileges and no access to host filesystem
5. **Token Handling**: Tokens are never logged or exposed in error messages
6. **Path Validation**: Directory operations enforce workspace-only access to prevent directory traversal attacks

## Testing

The executor service includes comprehensive tests:

**Container Manager Tests:**
- `ContainerManagerTests.*` - 24 tests for core container operations
- `DirectoryOperationsTests.*` - 25 unit tests for directory operations
- `DirectoryOperationsIntegrationTests.*` - 12 integration tests with real Docker containers

**Container Executor Tests:**
- `ContainerExecutorServiceTests.ExecutePlanAsync_ThrowsWhenPlanIsNull`
- `ContainerExecutorServiceTests.ExecutePlanAsync_CreatesAndCleansUpContainer`
- `ContainerExecutorServiceTests.ExecutePlanAsync_UpdatesTaskStatusToExecuting`
- `ContainerExecutorServiceTests.ExecutePlanAsync_PostsProgressComment`
- `ContainerExecutorServiceTests.ExecutePlanAsync_CommitsChanges`

**Legacy Executor Tests (for comparison):**
- `ExecutorServiceTests.ExecutePlanAsync_*` (8 tests)

**Directory Operations Coverage:**
- All operations (Create, Exists, Move, Copy, Delete, List) have dedicated tests
- Security validation tests ensure paths stay within `/workspace`
- Integration tests verify operations work with actual Docker containers

Run tests with:
```bash
dotnet test
```

All 268 tests pass successfully.

## Limitations & Future Enhancements

### Current Limitations

1. **No LLM Integration**: Steps are currently executed with basic build/test verification
2. **Limited MCP Tool Usage**: File read/write operations are available but not yet integrated with LLM for code modification
3. **Single Base Image**: Currently uses .NET SDK image; may need different images for different project types
4. **Synchronous Execution**: Long-running tasks block the thread

### Planned Enhancements

1. **LLM-Driven Code Modification**: Integrate MCP tools with LLM to actually read, analyze, and modify code files
2. **Multi-Language Support**: Add base images for Node.js, Python, Go, and other languages
3. **Background Processing**: Use background jobs for long-running executions
4. **Persistent Storage**: Store execution state and container logs in a database
5. **Advanced Error Recovery**: Retry failed commands and steps with exponential backoff
6. **Resource Limits**: Set CPU and memory limits for containers
7. **Incremental Commits**: Commit after each successful step instead of at the end
8. **Enhanced Testing**: Capture test results and code coverage metrics

## Example Usage

```csharp
// In WebhookHandler or a background job
var task = new AgentTask
{
    Id = "owner/repo/issues/123",
    InstallationId = 12345,
    RepositoryOwner = "owner",
    RepositoryName = "repo",
    IssueNumber = 123,
    Plan = new AgentPlan
    {
        ProblemSummary = "Fix bug in authentication",
        Steps = new List<PlanStep>
        {
            new() { Id = "1", Title = "Update auth middleware", Details = "Add missing null check" },
            new() { Id = "2", Title = "Add unit tests", Details = "Cover the new code path" }
        }
    }
};

// Execute the plan
await executorService.ExecutePlanAsync(task, cancellationToken);

// Task status is now Completed
// Changes are committed and pushed
// PR has a progress comment
```

## Troubleshooting

### Repository Clone Failures

- Ensure the installation token has `contents: write` permission
- Check that the branch exists in the repository
- Verify network connectivity to GitHub

### Command Execution Failures

- Ensure required tools (git, dotnet, npm, etc.) are installed
- Check working directory permissions
- Review command output in logs

### PR Comment Failures

- Verify installation token has `pull_requests: write` permission
- Ensure the PR exists and is open
- Check for rate limiting issues

## See Also

- [PLAN.md](PLAN.md) - Overall architecture and implementation plan
- [POC-SETUP.md](POC-SETUP.md) - Setup instructions
- [LLM-CONFIGURATION.md](LLM-CONFIGURATION.md) - LLM configuration guide
